Index: bytebrigade/home/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.shortcuts import render, redirect\nfrom home.models import Transaction, TransactionLike\nfrom account.models import Statistic\nfrom bins.models import BinData\nfrom products.models import Product\nimport geopy.distance\nimport calendar\n\n\n# function for the home page backend\ndef home_view(request):\n    \"\"\"\n    Web backend for '../' (name 'index')\n\n    This function intialises / resets session variables and handles POST and GET requests.\n    If the request is a GET, then the function retrieves the first 5 entries from the transaction\n    model and returns a render to 'index.html' passing a data_dict with the latest transaction\n    information.\n    If the request is a POST then the user is redirected to the scanner page.\n    \"\"\"\n    request.session['barcode'] = -1  # The barcode that the user has scanned\n    request.session['newHome'] = -1  # The closest bin\n    request.session['valid'] = -1  # If the user has scanned a product, they are valid for the scanner page\n    request.session['pokedex_barcode'] = -1\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.method == 'POST':\n        if (request.user and Transaction.objects.filter(transaction_id=request.POST.get(\"trans_id\"))):\n            trans = Transaction.objects.get(transaction_id=request.POST.get(\"trans_id\"))\n            print(trans)\n            if(not TransactionLike.objects.filter(user=request.user, transaction=trans)):\n                trans_like = TransactionLike(user=request.user, transaction=trans)\n                trans.likes += 1\n                trans_like.save()\n                trans.save()\n    if BinData.objects.count() == 0:\n        bins = [['FORUM-MAIN-OUT', 'Forum main entrance Outside', 50.735666895923100001, -3.533641953682420000, True, True, True, True, True, True, False, False],\n                ['IN-1-SWIOT-1', 'Innovation 1 SWIOT 1', 50.737929365592700001, -3.530370602541640000, False, False, False, True, False, True, True, False],\n                ['INTO-OUT', 'INTO Outside carpark', 50.7359469093508000018, -3.534357688043370000, True, False, False, True, False, True, True, False],\n                ['LAF-MAB', 'Lafrowda MA MB Bin shed', 50.734501000805200001, -3.527055005716390000, True, True, True, True, True, True, False, False],\n                ['ROWE', 'Rowe House Bin shed', 50.734291038584400001, -3.528512745930170000, True, True, True, True, True, True, False, False],\n                ['XFI-LEC', 'XFI Building Lecture', 50.735844192079400001, -3.529726038441900000, True, False, False, True, False, True, False, False]]\n        for item in bins:\n            print(item)\n            bin_ob = BinData(binId=item[0], binName=item[1], binLat=item[2], binLong=item[3], binPhoto='figures/bins/default.jpg', bin_general=item[4], bin_recycle=item[5], bin_paper=item[6], bin_cans=item[7], bin_glass=item[8], bin_plastic=item[9], bin_non_rec=item[10])\n            print(bin_ob)\n            bin_ob.save()\n    #  Retrieve liked transactions by the current user\n    liked = TransactionLike.objects.filter(user=request.user)\n    likedList = []\n    for x in liked:\n        likedList.append(x.transaction_id)\n    print(likedList)\n\n    data = Transaction.objects.all().order_by('-time')[:5]\n    data_dict = {\n        'Transaction': data,\n        'likedList': likedList\n    }\n\n    return render(request, 'home/index.html', data_dict) #  Return index page\n\n\n# Handles a request for the leaderboard page, ordering the users by their points\ndef getLeaderboard(request):\n    \"\"\"\n    Web backend for '../leaderboard/' (name 'leaderboard')\n\n    This function retrieves all entries from the statistic model ordered by the points\n    value in the model. It then returns a render of 'Leaderboard.html' passing the data_dict\n    with the model information.\n    \"\"\"\n\n    if not request.user.is_authenticated:\n        return redirect('login')  #  Redirects to login page if not logged in\n    statData = Statistic.objects.all().order_by('-points')\n    data_dict = {\n        'Statistics': statData,\n    }\n    return render(request, 'home/Leaderboard.html', data_dict)\n\n\ndef instruction_view(request):\n    \"\"\"\n    Web backend for '../abouts/' (name 'instruction')\n    Returns:\n        * The instruction about page.\n    \"\"\"\n    return render(request, 'home/about-me.html')\n\n\n# Function that checks you are within the minimum range of a bin and return's information about your closest bin\ndef withinRange(request, binType):\n    \"\"\"\n    This function calculates the distance of the closest bin of a particular type.\n\n    Parameters:\n        binType: The type of bin to be found\n\n    Returns:\n        shortestDistance: the shortest distance\n        close_bin: the longitude and latitude of the closest bin\n        bin_object: the closest bin_object that fits the binType requirements\n    \"\"\"\n\n    curr_lat = float(request.POST.get(\"location_lat\"))\n    curr_long = float(request.POST.get(\"location_long\"))\n    coords_1 = (curr_lat, curr_long)\n\n    shortestDistance = 100000000\n    close_bin = None\n    bin_object = None\n\n    for bin in BinData.objects.all():\n        coords_2 = (bin.binLat, bin.binLong)\n        distance = geopy.distance.geodesic(coords_1, coords_2).m\n        if distance < shortestDistance:\n            if bin.bin_general and (binType == 'General'):\n                shortestDistance = distance\n                close_bin = coords_2\n                bin_object = bin\n            if bin.bin_paper and (binType == 'Paper'):\n                shortestDistance = distance\n                close_bin = coords_2\n                bin_object = bin\n            if bin.bin_cans and (binType == 'Cans'):\n                shortestDistance = distance\n                close_bin = coords_2\n                bin_object = bin\n            if bin.bin_glass and (binType == 'Glass'):\n                shortestDistance = distance\n                close_bin = coords_2\n                bin_object = bin\n            if bin.bin_plastic and (binType == 'Plastic'):\n                shortestDistance = distance\n                close_bin = coords_2\n                bin_object = bin\n    return shortestDistance, close_bin, bin_object\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bytebrigade/home/views.py b/bytebrigade/home/views.py
--- a/bytebrigade/home/views.py	(revision f732113694b32e921d69a2f3370c1e11f308611e)
+++ b/bytebrigade/home/views.py	(date 1679341175433)
@@ -27,7 +27,6 @@
     if request.method == 'POST':
         if (request.user and Transaction.objects.filter(transaction_id=request.POST.get("trans_id"))):
             trans = Transaction.objects.get(transaction_id=request.POST.get("trans_id"))
-            print(trans)
             if(not TransactionLike.objects.filter(user=request.user, transaction=trans)):
                 trans_like = TransactionLike(user=request.user, transaction=trans)
                 trans.likes += 1
@@ -41,16 +40,13 @@
                 ['ROWE', 'Rowe House Bin shed', 50.734291038584400001, -3.528512745930170000, True, True, True, True, True, True, False, False],
                 ['XFI-LEC', 'XFI Building Lecture', 50.735844192079400001, -3.529726038441900000, True, False, False, True, False, True, False, False]]
         for item in bins:
-            print(item)
             bin_ob = BinData(binId=item[0], binName=item[1], binLat=item[2], binLong=item[3], binPhoto='figures/bins/default.jpg', bin_general=item[4], bin_recycle=item[5], bin_paper=item[6], bin_cans=item[7], bin_glass=item[8], bin_plastic=item[9], bin_non_rec=item[10])
-            print(bin_ob)
             bin_ob.save()
     #  Retrieve liked transactions by the current user
     liked = TransactionLike.objects.filter(user=request.user)
     likedList = []
     for x in liked:
         likedList.append(x.transaction_id)
-    print(likedList)
 
     data = Transaction.objects.all().order_by('-time')[:5]
     data_dict = {
Index: bytebrigade/shop/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.core.mail import EmailMessage\nfrom django.shortcuts import render, redirect\nimport qrcode\nimport qrcode.image.svg\nfrom io import BytesIO\nfrom .models import ShopItems\nfrom account.models import Statistic\n\nfrom django.core.mail import EmailMultiAlternatives\nfrom django.template.loader import render_to_string\n# Create your views here.\ndef shop_view(request):\n    \"\"\"\n    This function will handle the shop page view. A user will be presented the shop page to which they can select\n    which item they would like to buy. This will then be returned to the user by email after a successful purchase.\n    \"\"\"\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.method == 'POST':\n        print(\"hi\")\n        item_id = request.POST.get(\"shop_item\")\n        item = ShopItems.objects.get(item_id=item_id)\n        item_purchased(request.user, item)\n\n    data = ShopItems.objects.all()\n    data_dict = {'shop_items': data}\n    return render(request, 'shop.html', data_dict)\n\ndef item_purchased(user, item):\n    \"\"\"\n    This procedure handles the purchase of a given item. First we must check that the user can afford this item and then\n    if they can we then purchase the product and then email them a QR code\n    \"\"\"\n    user_stats = Statistic.objects.get(user=user)\n    print(\"hi\")\n    if(item.stock == 0):\n        return redirect('shop_view')\n    if(user_stats.points>=item.cost):\n        item.stock -= 1\n        item.save()\n        user_stats.points -= item.cost\n        user_stats.save()\n\n        qr = qrcode.QRCode(version=1, box_size=10, border=5)\n        qr.add_data(item.name)\n        qr.make(fit=True)\n\n        img = qr.make_image(fill_color='black', back_color='white')\n        buffer = BytesIO()\n        img.save(buffer, format='PNG')\n        qr_image_data = buffer.getvalue()\n\n        email = EmailMultiAlternatives(\n            subject='Shop Purchase',\n            body='Attached is your purchase QRcode. Please show this to a member of staff',\n            from_email='bytebrigade@outlook.com',\n            to=[user.email],\n        )\n        # Attach the QR code image as an inline attachment\n        email.attach('qrcode.png', qr_image_data, 'image/png')\n        email.send()\n    else:\n        # They cannot afford the product\n        return redirect('shop_view')\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bytebrigade/shop/views.py b/bytebrigade/shop/views.py
--- a/bytebrigade/shop/views.py	(revision f732113694b32e921d69a2f3370c1e11f308611e)
+++ b/bytebrigade/shop/views.py	(date 1679341219223)
@@ -17,7 +17,6 @@
     if not request.user.is_authenticated:
         return redirect('login')
     if request.method == 'POST':
-        print("hi")
         item_id = request.POST.get("shop_item")
         item = ShopItems.objects.get(item_id=item_id)
         item_purchased(request.user, item)
@@ -32,7 +31,6 @@
     if they can we then purchase the product and then email them a QR code
     """
     user_stats = Statistic.objects.get(user=user)
-    print("hi")
     if(item.stock == 0):
         return redirect('shop_view')
     if(user_stats.points>=item.cost):
Index: bytebrigade/barcodereader/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.shortcuts import render, redirect\nfrom home.models import Transaction\nfrom products.models import Product\nfrom bins.models import BinData\nfrom datetime import datetime, time\nfrom account.views import addstats, update_goal_stat\n\n\ndef scanner_page_view(request):\n    # If the user not log-in, redirect them to login page\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.method == 'POST':\n        barcode_product = request.POST.get(\"barcode\")\n        # We set the session barcode so that we can then use it in the other areas of the project\n        request.session['barcode'] = barcode_product\n        request.session['valid'] = 1\n        if Product.objects.filter(barcode=barcode_product).exists():\n            return redirect('product_info')\n            # redirect to product recycle page\n        else:\n            return redirect('create_product')\n    else:\n        return render(request, 'BCscanner/Scanner_page.html')\n\n\ndef recycle_confirm_view(request):\n    # This is function handles the user successfully getting to the bin\n    if not request.user.is_authenticated:\n        return redirect('login')\n    try:\n        if not request.session['valid'] == 1:\n            return redirect('index')\n    except Exception as e:\n        print(e)\n        return redirect(\"index\")\n    try:\n        barcode_product = request.session['barcode']\n        bin_id = request.session['newHome']\n        print(barcode_product)\n        print(bin_id)\n        if Product.objects.filter(barcode=barcode_product).exists() \\\n                and BinData.objects.filter(binId=bin_id).exists():\n            product_data = Product.objects.get(barcode=barcode_product)\n            user_data = request.user\n            cur_time = (datetime.now()).strftime(\"%H:%M:%S\")\n            bin_data = BinData.objects.get(binId=bin_id)\n            new_transaction = Transaction.objects.create(\n                product=product_data,\n                user=user_data,\n                time=cur_time,\n                bin=bin_data,\n            )\n            new_transaction.save()\n            request.session['barcode'] = -1\n            request.session['valid'] = -1\n            request.session['newHome'] = -1\n            # Call a function that will take in the calculate the points for the user\n            # If the product is new add points, this is handle in the create product part\n            weight = product_data.weight\n\n            now = datetime.now().time()  # get the current time\n\n            if now >= time(9, 0) and now <= time(15, 0):\n                points = round(weight * 122) * 2\n                peak = True;\n            else:\n                points = round(weight * 122)\n                peak = False;\n\n            addstats(request.user, product_data, points, weight)  # need to include the product\n            update_goal_stat(request.user, product_data)\n    except Exception as e:\n        print(e)\n\n    data = Transaction.objects.all().order_by('-time')[:5]\n    data_dict = {\n        'Transaction': data,\n        'points': points,\n        'peakTime': peak\n    }\n    return render(request, 'home/index.html', data_dict)\n\n\ndef database_lookup(request):\n    print(request.POST)\n    barcode_camera = request.POST.get(\"barcode\")\n    print(\"Value is \", barcode_camera)\n    if Product.objects.filter(barcode=barcode_camera).exists():\n        print(\"in db\")\n        product_data = Product.objects.get(barcode=barcode_camera)\n        print(product_data)\n    else:\n        print(\"not in db\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bytebrigade/barcodereader/views.py b/bytebrigade/barcodereader/views.py
--- a/bytebrigade/barcodereader/views.py	(revision f732113694b32e921d69a2f3370c1e11f308611e)
+++ b/bytebrigade/barcodereader/views.py	(date 1679341154471)
@@ -37,8 +37,6 @@
     try:
         barcode_product = request.session['barcode']
         bin_id = request.session['newHome']
-        print(barcode_product)
-        print(bin_id)
         if Product.objects.filter(barcode=barcode_product).exists() \
                 and BinData.objects.filter(binId=bin_id).exists():
             product_data = Product.objects.get(barcode=barcode_product)
@@ -82,13 +80,10 @@
     return render(request, 'home/index.html', data_dict)
 
 
-def database_lookup(request):
-    print(request.POST)
-    barcode_camera = request.POST.get("barcode")
-    print("Value is ", barcode_camera)
-    if Product.objects.filter(barcode=barcode_camera).exists():
-        print("in db")
-        product_data = Product.objects.get(barcode=barcode_camera)
-        print(product_data)
-    else:
-        print("not in db")
+# def database_lookup(request):
+#     barcode_camera = request.POST.get("barcode")
+#     if Product.objects.filter(barcode=barcode_camera).exists():
+#         product_data = Product.objects.get(barcode=barcode_camera)
+#         print(product_data)
+#     else:
+#         print("not in db")
Index: bytebrigade/products/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.shortcuts import render, redirect\nfrom .models import Product\nfrom account.views import addstats\nfrom home.views import withinRange\nfrom home.models import Transaction\nfrom django.db.models import Q, Count\nfrom django.http import HttpResponse\n\ndef product_dex(request):\n    \"\"\"\n    Web backend for '../product/dex/' (name 'product_dex')\n    \n    This function creates a information page on the number of every product that a user has binned\n    \"\"\"\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.method == 'POST':\n        request.session['pokedex_barcode'] = request.POST.get('barcode')\n        return redirect('product_info')\n\n    # Data is all transactions from the current user\n    data = Transaction.objects.filter(Q(user=request.user))\n\n\n    # Create a dictionary of unique items that appear in transaction and keep a count\n    items = {}\n    for obj in data:\n        key = obj.product\n        if key not in items.keys():\n            items[key] = 1\n        else:\n            items[key] +=1\n\n    print(items)\n    product_count = {\n        'product': items\n    }\n\n    return render(request, 'products/pokedex.html', product_count)  #  Render pokedex page\n\ndef create_product_view(request):\n    \"\"\"\n    This view handles the product creation page. When the user scans a product if the product is not in the database\n    we then ask the user to fill out a form about this product. If the request is a get request we load the page containing\n    the product form. When a post request occurs we collect the product information and add it to the database.\n\n    The page will automatically contain the barcode which the user has scanned.\n    \"\"\"\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.method == 'POST': # Add the product to the database\n        form = request.POST\n        new_product = Product.objects.create(\n            barcode=form.get(\"barcode\"),\n            name=form.get(\"name\"),\n            weight=float(form.get(\"weight\")) / 1000,\n            material=form.get(\"material\"),\n            recycle=form.get(\"recycle\")\n        )\n        new_product.save()\n\n        product_data = Product.objects.get(barcode=form.get(\"barcode\"))\n        addstats(request.user, product_data, 50)\n\n        request.session['new_product'] = True\n\n        return redirect('product_info')\n    elif request.session['barcode'] != -1: # Collect the barcode that the user has provided\n        if not Product.objects.filter(barcode=request.session['barcode']).exists():\n            barcode = {'barcode': request.session['barcode']}\n            return render(request, 'products/new_product_page.html', barcode) # Present the barcdoe in the page\n        else:\n            return redirect('index')\n    return redirect('index')\n\n\n\ndef prompt_recycle_product_view(request):\n    \"\"\"\n    This view handles the viewing of a product that the user has just scanned or previously scanned\n    If they have just scanned the product then they will be prompted with a button to recycle the product.\n    Below we calculate what bin the product should go into, and then use this data to load the map of bins.\n    \"\"\"\n    if not request.user.is_authenticated:\n        return redirect('login')\n    if request.session['barcode'] != -1:\n        product = Product.objects.get(barcode=request.session['barcode'])\n        binType = check_bin(product)\n        if request.method == 'POST':\n            shortestDistance, close_bin, bin_object = withinRange(request, binType)\n            request.session['newHome'] = bin_object.binId  # Directly correlates to a bin\n            print(request.session['newHome'])\n            return redirect(\"bin_map\")\n        else:\n            data = {\"name\": product.name,\n                    \"barcode\": request.session['barcode'],\n                    \"weight\": product.weight,\n                    \"material\": product.material,\n                    \"recycle\": product.recycle,\n                    \"present_button\": 1,\n                    \"binType\": binType,\n                    \"history\": Transaction.objects.filter(user=request.user, product=product),\n                    }\n    if request.session['pokedex_barcode'] != -1:\n        product = Product.objects.get(barcode=request.session['pokedex_barcode'])\n        binType = check_bin(product)\n        data = {\"name\": product.name,\n                \"barcode\": request.session['pokedex_barcode'],\n                \"weight\": product.weight,\n                \"material\": product.material,\n                \"recycle\": product.recycle,\n                \"present_button\": 0,\n                \"binType\": binType,\n                \"history\": Transaction.objects.filter(user=request.user, product=product),\n                }\n    return render(request, 'products/info_product.html', data)\n\n    # product = Product.objects.get(barcode=request.session['barcode'])\n    # if request.method == 'POST':\n    #     binType = \"General\"\n    #     match (product.material, product.recycle):\n    #         case (\"Paper\", \"True\"):\n    #             binType = 'Paper'\n    #         case (\"Plastic\", \"True\"):\n    #             binType = 'Plastic'\n    #         case (\"Cans\", \"True\"):\n    #             binType = 'Cans'\n    #         case (\"Glass\", \"True\"):\n    #             binType = 'Glass'\n    #         case (\"Plastic\", \"False\"):\n    #             binType = 'General'\n    #         case (\"Cans\", \"False\"):\n    #             binType = 'General'\n    #         case (\"Non-Recyclable\", \"False\"):\n    #             binType = 'General'\n    #         case (\"Glass\", \"False\"):\n    #             binType = 'General'\n    #     shortestDistance, close_bin, bin_object = withinRange(request, binType)\n    #     request.session['newHome'] = bin_object.binId  # Directly correlates to a bin\n    #     print(request.session['newHome'])\n    #     return redirect(\"bin_map\")\n    # data = {\"name\": product.name,\n    #         \"barcode\": request.session['barcode'],\n    #         \"weight\": product.weight,\n    #         \"material\": product.material,\n    #         \"recycle\": product.recycle,\n    #         \"present_button\": 1,\n    #         }\n    # return render(request, 'products/info_product.html', data)\n\ndef check_bin(product):\n    binType = \"General\"\n    match (product.material, product.recycle):\n        case (\"Paper\", \"True\"):\n            binType = 'Paper'\n        case (\"Plastic\", \"True\"):\n            binType = 'Plastic'\n        case (\"Cans\", \"True\"):\n            binType = 'Cans'\n        case (\"Glass\", \"True\"):\n            binType = 'Glass'\n        case (\"Plastic\", \"False\"):\n            binType = 'General'\n        case (\"Cans\", \"False\"):\n            binType = 'General'\n        case (\"Non-Recyclable\", \"False\"):\n            binType = 'General'\n        case (\"Glass\", \"False\"):\n            binType = 'General'\n    return binType\n\n\ndef database_lookup(request):\n    \"\"\"\n    This function is used to check if a product exists in the database already.\n    \"\"\"\n    print(request.POST)\n    barcode_camera = request.POST.get(\"barcode\")\n    print(\"Value is \", barcode_camera)\n    if Product.objects.filter(barcode=barcode_camera).exists():\n        print(\"in db\")\n        product_data = Product.objects.get(barcode=barcode_camera)\n        print(product_data)\n    else:\n        print(\"not in db\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bytebrigade/products/views.py b/bytebrigade/products/views.py
--- a/bytebrigade/products/views.py	(revision f732113694b32e921d69a2f3370c1e11f308611e)
+++ b/bytebrigade/products/views.py	(date 1679341203609)
@@ -31,7 +31,6 @@
         else:
             items[key] +=1
 
-    print(items)
     product_count = {
         'product': items
     }
@@ -115,38 +114,7 @@
                 }
     return render(request, 'products/info_product.html', data)
 
-    # product = Product.objects.get(barcode=request.session['barcode'])
-    # if request.method == 'POST':
-    #     binType = "General"
-    #     match (product.material, product.recycle):
-    #         case ("Paper", "True"):
-    #             binType = 'Paper'
-    #         case ("Plastic", "True"):
-    #             binType = 'Plastic'
-    #         case ("Cans", "True"):
-    #             binType = 'Cans'
-    #         case ("Glass", "True"):
-    #             binType = 'Glass'
-    #         case ("Plastic", "False"):
-    #             binType = 'General'
-    #         case ("Cans", "False"):
-    #             binType = 'General'
-    #         case ("Non-Recyclable", "False"):
-    #             binType = 'General'
-    #         case ("Glass", "False"):
-    #             binType = 'General'
-    #     shortestDistance, close_bin, bin_object = withinRange(request, binType)
-    #     request.session['newHome'] = bin_object.binId  # Directly correlates to a bin
-    #     print(request.session['newHome'])
-    #     return redirect("bin_map")
-    # data = {"name": product.name,
-    #         "barcode": request.session['barcode'],
-    #         "weight": product.weight,
-    #         "material": product.material,
-    #         "recycle": product.recycle,
-    #         "present_button": 1,
-    #         }
-    # return render(request, 'products/info_product.html', data)
+
 
 def check_bin(product):
     binType = "General"
Index: bytebrigade/account/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.shortcuts import render, redirect\nfrom django.http import HttpResponseRedirect\nfrom .forms import RegistrationForm\nfrom .models import Statistic, Goal, UserGoal\nfrom home.models import Transaction\nfrom django.urls import reverse\nfrom django.db.models import Q\nfrom products.models import Product\nimport datetime\nimport calendar\nimport schedule\nfrom django.core.mail import send_mail\nfrom django.template.loader import render_to_string\nfrom django.db.models import Count\n\ndef register(request):\n    \"\"\"\n    Web backend for '../account/registration' (name 'registration')\n\n    Returns:\n        * for 'POST' method:\n            -> Registration page if form is not valid (Error information appears)\n            -> Success-welcome page if form is valid and create the new user.\n        * Registration page if used 'GET' method.\n    \"\"\"\n    if request.user.is_authenticated:\n        return redirect('index')\n    if Product.objects.count() == 0:\n        default_product = Product(\n            barcode='1', name='None', weight=0, material='None', recycle='None')\n        default_product.save()\n    if request.method == 'POST':\n        user_form = RegistrationForm(request.POST)\n        if user_form.is_valid():\n            if user_form.cleaned_data['password'] != user_form.cleaned_data['password_confirm']:\n                return render(request, 'registration/register.html', {'user_form': user_form})\n            # New user object without saving\n            new_user = user_form.save(commit=False)\n            # Set password\n            new_user.set_password(user_form.cleaned_data['password'])\n            new_user.save()\n            new_statistic = Statistic.objects.create(user=new_user)\n            new_statistic.save()\n            return render(request, 'registration/register_done.html', {'new_user': new_user})\n    else:\n        user_form = RegistrationForm()\n    return render(request, 'registration/register.html', {'user_form': user_form})\n\n\ndef password(request):\n    return render(request, 'account/password.html')\n\n\ndef account(request):\n    \"\"\"\n    Web backend for 'account/' (name 'account')\n    Display user recycle stats and points if the user is authenticated.\n\n    Returns:\n        * Account page with user recycle stats if user authenticated.\n        * Redirect to login page if user is not authenticated.\n    \"\"\"\n    schedule.run_pending()\n    if request.user.is_authenticated:\n        data = Statistic.objects.get(user=request.user)\n        loveRecycling = 0\n        lastTransaction = 0\n        if Transaction.objects.filter(user=request.user).exists():\n            lastTransaction = Transaction.objects.filter(\n                user=request.user).latest('time')\n            transactionCount = Transaction.objects.annotate(num_transactions=Count('product', filter=Q(user=request.user)))\n            loveRecycling = transactionCount.first()\n        maxWeek = Statistic.objects.all().order_by('-curweek')[0]\n        maxMonth = Statistic.objects.all().order_by('-curmonth')[0]\n        maxYear = Statistic.objects.all().order_by('-curyear')[0]\n        goalData = Goal.objects.all()\n        userGoal1 = UserGoal.objects.filter(\n            Q(userGoalNum=1) & Q(user=request.user)).first()\n        userGoal2 = UserGoal.objects.filter(\n            Q(userGoalNum=2) & Q(user=request.user)).first()\n        userGoal3 = UserGoal.objects.filter(\n            Q(userGoalNum=3) & Q(user=request.user)).first()\n        data_dict = {\n            'Profile': data,\n            'maxWeek': maxWeek,\n            'maxMonth': maxMonth,\n            'maxYear': maxYear,\n            'Goals': goalData,\n            'UserGoal1': userGoal1,\n            'UserGoal2': userGoal2,\n            'UserGoal3': userGoal3,\n            'lastTrans': lastTransaction,\n            'loveRecycling': loveRecycling\n        }\n        return render(request, 'account/Profile_page.html', data_dict)\n    else:\n        return redirect('login')\n\n\ndef addUserGoal(request):\n    \"\"\"\n    Web backend for '../account/addUserGoal/' (name 'addUserGoal')\n    Create UserGoal model and redirect user back to account page.\n\n    Returns:\n        * Redirect to account page.\n    \"\"\"\n    x = request.POST['goalNum']\n    y = request.POST['goal-options']\n    # This comment may no longer be needed -> # this is plastic and all the others\n    z = request.POST['goal-type']\n    goalNumType = Goal.objects.get(pk=y)\n    current_user = request.user\n    # Checking if the user has already got a goal for this specific value\n    goalSet = UserGoal.objects.filter(Q(userGoalNum=x) & Q(user=current_user))\n    if not goalSet:\n        goal = UserGoal(userGoalNum=x, user=current_user,\n                        goal=goalNumType, value=0, goalType=z)\n        goal.save()\n    else:\n        UserGoal.objects.filter(\n            Q(userGoalNum=x) & Q(user=current_user)).delete()\n        goal = UserGoal(userGoalNum=x, user=current_user,\n                        goal=goalNumType, value=0, goalType=z)\n        goal.save()\n    return HttpResponseRedirect(reverse('account'))\n\n\ndef addstats(user, product, points: int, kg=0):\n    \"\"\"\n    Function that calculate point gain from recycle and add it into user point.\n\n    params:\n        user - the user object having points added to\n        product - the product object which is giving them points\n        points - the points being added to the user object\n        kg - the kg amount being added to the users stats\n    \"\"\"\n    print(\"In add stats\")\n    user_stats = Statistic.objects.get(user=user)\n    user_stats.points += points\n    kg *= 0.09\n    kg = round(kg, 3)\n    user_stats.curweek = round((user_stats.curweek + kg), 3)  # change field\n    user_stats.curmonth = round((user_stats.curmonth + kg), 3)\n    user_stats.curyear = round((user_stats.curyear + kg), 3)\n    user_stats.carbon = round(((user_stats.carbon + kg)*0.24), 3)\n    user_stats.lastRecycle = product\n    user_stats.save()  # this will update only\n\n\ndef update_goal_stat(user, product):\n    \"\"\"\n    Check and update user goal when user reached the requirement.\n\n    params:\n        user - the user who is having their goal updated\n        product - the product which the user has recycled.\n    \"\"\"\n    material = product.material\n    recyclable = product.recycle\n    if recyclable:\n        bin_type = material\n    else:\n        bin_type = 'General Waste'\n    user_goals = UserGoal.objects.filter(Q(goalType=bin_type) & Q(user=user))\n    for item in user_goals:\n        item.value += 1\n        item.save()\n    # Delete full goals and add points\n    for item in user_goals:\n        if item.value >= 100:\n            item.delete()\n            user.points += 100\n\n\ndef send_carbon_footprint_email(user):\n    \"\"\"\n    This function will email the user after their stats have been reset by the schedular below. They will be email\n    info on week, month, year and carbon\n\n    params:\n        user - this is the user object which we will be working with and emailing stats to.\n    \"\"\"\n    user_stats = Statistic.objects.get(user=user)\n    week_data = user_stats.curweek\n    month_data = user_stats.curmonth\n    year_data = user_stats.curyear\n    carbon_data = user_stats.carbon\n    html_message = render_to_string('carbon_footprint_email.html', {\n                                    'User': user, 'Carbon': carbon_data, 'WeekData': week_data, 'MonthData': month_data, 'YearData': year_data})\n    send_mail(\n        'Your Carbon Footprint Report',\n        '',\n        'bytebrigade@outlook.com',\n        [user.email],\n        html_message=html_message,\n        fail_silently=False,\n    )\n\n\ndef reset_week():\n    \"\"\"\n    It is the end of the week so we reset all the weekly stats\n    \"\"\"\n    for item in Statistic.objects.all():\n        send_carbon_footprint_email(item.user)\n        item.curweek = 0\n        item.save()\n\n\ndef reset_month():\n    \"\"\"\n    It is the end of the month potentially, so we reset the monthly stats\n    \"\"\"\n    if datetime.datetime.now().day == 1:\n        for item in Statistic.objects.all():\n            send_carbon_footprint_email(item.user)\n            item.curmonth = 0\n            item.save()\n\n\ndef reset_year():\n    \"\"\"\n    It is the end of the year potentially, so we reset the year stats\n    \"\"\"\n    if datetime.datetime.now().month == 1 and datetime.datetime.now().day == 1:\n        for item in Statistic.objects.all():\n            send_carbon_footprint_email(item.user)\n            item.curyear = 0\n            item.save()\n\n\n# Schedule the reset_stats function to run on the last day of each week, month and year  at 00:00 AM\nschedule.every().sunday.at(\"00:00\").do(reset_week)\nschedule.every().day.at(\"00:00\").do(reset_year)\nschedule.every().day.at(\"00:00\").do(reset_month)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bytebrigade/account/views.py b/bytebrigade/account/views.py
--- a/bytebrigade/account/views.py	(revision f732113694b32e921d69a2f3370c1e11f308611e)
+++ b/bytebrigade/account/views.py	(date 1679341068517)
@@ -136,7 +136,6 @@
         points - the points being added to the user object
         kg - the kg amount being added to the users stats
     """
-    print("In add stats")
     user_stats = Statistic.objects.get(user=user)
     user_stats.points += points
     kg *= 0.09
