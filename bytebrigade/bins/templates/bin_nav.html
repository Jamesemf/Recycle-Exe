{% extends 'navbar.html' %}
{% load static %}

{% block title %} Bin Navigation {% endblock %}

{% block style %}
<style>
    .compass {
        position: relative;
        width: 70vw;
        height: 70vw;
        border-radius: 50%;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        margin: auto;
    }

    .compass > .compass-circle,
    .compass > .my-point {
        position: absolute;
        width: 90%;
        height: 90%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.1s ease-out;
        background: url({% static 'figures/arrow.png' %})
            center no-repeat;
        background-size: contain;
    }

    #compass{
        vertical-align: middle;
        width: 50%;
        height: 50%;
    }

    .compass > .my-point {
        opacity: 0;
        width: 20%;
        height: 20%;
        background: rgb(8, 223, 69);
        border-radius: 50%;
        transition: opacity 0.5s ease-out;
    }

    .start-btn {
        margin-bottom: auto;
    }
</style>
{% endblock %}

{% block content %}
    <div class="card main-content">
        <div class="card-body">
            <div style="text-align: center;">
                <h6 class="text-muted mb-2">Finding</h6>
                <h4>{{ BinGoal.binName }}</h4>
            </div>
            <div style="text-align: center;">
                <h6 class="text-muted mb-2" id="distance"></h6>
            </div>
            <div style="text-align: center;">
                <div class="compass">
                    <img id="compass" src="{% static 'figures/arrow.png' %}">
                    <div class="compass-circle"></div>
                    <div class="my-point"></div>
                </div>
                <button class="start-btn" style="visibility: hidden;">Start compass</button>
            </div>
            <div>
                <form id = "formId" method="POST">
                    {% csrf_token %}
                    <input type="hidden" name="distance" id="distance" value=0>
                </form>
            </div>
        </div>
    </div>
{% endblock %}

{% block script %}
<script>
    // Gets the html elements with the relevant classes
    const compassCircle = document.querySelector(".compass-circle");
    const compassImg = document.getElementById(compass);
    const myPoint = document.querySelector(".my-point");
    const startBtn = document.querySelector(".start-btn");

    // Checks if the device uses IOS or not
    const isIOS =
      navigator.userAgent.match(/(iPod|iPhone|iPad)/) &&
      navigator.userAgent.match(/AppleWebKit/);

    /** Function run when the page opens
     *
     *  Runs the handler function if the devise isn't ios
     */
    function init() {
        startBtn.addEventListener("click", startCompass);
        navigator.geolocation.getCurrentPosition(locationHandler);

      if (!isIOS) {
          console.log("NOT IOS");
          window.addEventListener("deviceorientationabsolute", handler, true);
      }
    }

    /** starts compass if it is IOS
     *
     */
    function startCompass() {
      if (isIOS) {
        // Requests permission
        DeviceOrientationEvent.requestPermission().then((response) => {
            if (response === "granted") {
              window.addEventListener("deviceorientation", handler, true);
            } else {
              alert("has to be allowed!");
            }
          })
          .catch(() => alert("not supported"));
      }
    }

    /** Starts compass if not IOS
     *
     * @param e
     */
    function handler(e) {
        console.log("HANDLER");
        compass = e.webkitCompassHeading || Math.abs(e.alpha - 360);
        compassCircle.style.transform = `translate(-50%, -50%) rotate(${-compass}deg)`;

        // Â±15 degree
        if((pointDegree < Math.abs(compass) && pointDegree + 15 > Math.abs(compass)) || pointDegree > Math.abs(compass + 15) || pointDegree < Math.abs(compass))
        {
            myPoint.style.opacity = 0;
        } else if (pointDegree) {
            myPoint.style.opacity = 1;
      }
    }

    // Automatically refreshes the degree to point to at a set interval
    let pointDegree;
    let auto_refresh = setInterval(function() { navigator.geolocation.getCurrentPosition(locationHandler); }, 3000);
    function locationHandler(position) {
      const { latitude, longitude } = position.coords;
      pointDegree = calcDegreeToPoint(latitude, longitude);

      if (pointDegree < 0) {
        pointDegree = pointDegree + 360;
      }
      binDistance(latitude,longitude)
    }

    /**
     * Calculates the actual degree to point to
     * @param latitude
     * @param longitude
     * @returns {number}
     */
    function calcDegreeToPoint(latitude, longitude) {
      {# Chaneg this to be the bin location#}
      const point = {
        lat: {{BinGoal.binLat}} ,
        long: {{BinGoal.binLong}} };

      const psi = bearing(latitude, longitude, point.lat, point.long);

      return Math.round(psi);
    }

    /**
     * Function converts from degree to radians
     *
     * @param degrees
     * @returns {number}
     *
     * */
    function toRadians(degrees) {
      return degrees * Math.PI / 180;
    }
    /**
     *  Function converts from radians to degrees
     *
     * @param radians
     * @returns {number}
     */
    function toDegrees(radians) {
      return radians * 180 / Math.PI;
    }


    /**
     * Calculates the bearing from one starting position to another position
     *
     * @param startLat
     * @param startLng
     * @param destLat
     * @param destLng
     * @returns {number}
     */
    function bearing(startLat, startLng, destLat, destLng){
      startLat = toRadians(startLat);
      startLng = toRadians(startLng);
      destLat = toRadians(destLat);
      destLng = toRadians(destLng);

      y = Math.sin(destLng - startLng) * Math.cos(destLat);
      x = Math.cos(startLat) * Math.sin(destLat) -
            Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLng - startLng);
      brng = Math.atan2(y, x);
      brng = toDegrees(brng);
      return (brng + 360) % 360;
    }

    /**
     *
     *
     * @param deg
     * @returns {number}
     */
    function deg2rad(deg) {
        return deg * (Math.PI / 180);
    }

    // Calculates distance between startLat and endLat
    /**
     *
     * @param latitude
     * @param longitude
     */
    function binDistance(latitude,longitude){
        var lat1 = latitude;
        var lon1 = longitude;
        var lat2= {{BinGoal.binLat}};
        var lon2= {{BinGoal.binLong}};
        var R = 6371; // Radius of the earth in km
        var dLat = deg2rad(lat2 - lat1);  // deg2rad below
        var dLon = deg2rad(lon2 - lon1);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = 1000 * R * c; // Distance in m
        d = d.toFixed(2);
        document.getElementById('distance').innerHTML = "Distance to bin: "+d+"m";
        if (d<=3) {
            document.getElementById("formId").submit();
        }
    }
    init();
</script>

{% endblock %}